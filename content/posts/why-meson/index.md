+++
"author" = "ret2libc"
"title" = "Why meson"
"date" = "2020-12-11"
"summary" = "Why we chose meson"
"tags" = ["dev"]

"ShowToc" = false
"weight" = 2
+++

# TL;DR
- It is fast, no files are recompiled if not necessary
- It is declarative, easy to understand, approach
- It keeps your source directory clean with out-of-source builds
- It makes it easy to build and run multiple versions of Rizin

# A bit of context

Historically radare2 has been compiled with the usual `./configure;make`
approach. This essentially consists of a sh script, `configure`, and a (set
of) Makefile(s). `configure` allows the user to customize the
compilation/installation process performed by `make`, by setting for example
the destination directories where executables, libraries, etc. are
installed on the system. It is also used to enable/disable specific features
(e.g. the debugger) or check for the existence of specific libraries, header
files, functions, compiler or linker arguments.

To some, this may be very similar to what is done by Autotools, however in
radare2/Rizin case, `configure` is generated by another sh script, `acr`, by
parsing a `configure.acr` file. `acr` is a tool developed by pancake, the
author of radare2, and it is an autoconf replacement.

In 2017 pancake started introducing another build system which could be used
to compile radare2: `meson`. Since then, several other people, including
myself, has improved this system to compile on several platforms and making
sure it is (almost) even feature-wise with the ACR/Make build system.

Rizin has chosen to deprecate the use of ACR/Make and switch to `meson` as
the main build system. We believe this will make the overall build process
more standard, easy to understand and to integrate with other
tools/libraries.

# Problems with ACR/Make

There are of course several reasons for this choice,
so let's first see what *we* believe are the problems of the historical
approach:

- ACR is essentially a one person project, with mostly only radare2 and other
radare-related tools using it. This by itself is not a bad thing, but it
comes with the downside that you find no help or documentation online and if
you have issues or missing features, you have only to rely on one person who
understand its internals. Moreover, the features you find are usually just
the ones used by radare2 project (e.g. not long ago, it was not possible to
easily check if the compiler supported a particular compilation flag, because
it was never necessary in radare2).
- `configure` script needs a sh shell, which makes it hard to use on
platforms such as Windows. There are of course ways to use it, but they may
involve installing MinGW or similars, which may not be ideal for Windows
users who usually work within Visual Studio.
- Makefiles can be written in a very flexible way and they can be used to
perform any sort of action, from simply compiling a C file to running scp,
various scripts and much more. Flexibility shall not be abused though,
otherwise it may become hard to understand how things are actually done (e.g.
understanding how `librz_io.so` is compiled involves looking at the Makefile
in `libr/io`, which includes `config.mk` that setups some variables based on
other variables defined in the Makefile and then it includes `rules.mk`,
which uses those variables to actually compile the library. Inside `rules.mk`
you find, hidden with various environment variables, the commands used to
build the object files and, then, the library).
- It is "low-level", which means that the Makefiles specifies the specific
commands, flags and options that you have to use to actually compile a
binary, a library or an object file. This provides a lot of power, but it may
also be overwhelming having to remember to add specific compilation/linking
flags for compiling a single file.

# What we like about the Meson Build System

- It is declarative, which means you don't have to remember or care about how
to actually compile a shared library or a static library on Linux, Windows,
BSD, etc. or how to link an executable with some other libraries or make sure
include paths are right. As an example:
```
library('io',
  ['file1.cpp', 'file2.cpp'],
  dependencies: [util_dep],
  install: true,
  soversion: rz_asm_lib.version()
)
```
You don't need to know *how* meson is going to build your library, but it is
going to do it by compiling two source files (e.g. `file1.cpp` and
`file2.cpp`), name the library `io` (e.g. on Linux the library would be
called `libio.so`, but the full name and the extensions might be different on
Windows) and give it the proper API version, make sure the dependency
specified by `util_dep`, whatever it is, is used to compile this library, by
adding the proper include paths and link directives.
- It is *fast*. ACR/Make, due to its complexity as implemented in
radare2/Rizin, does not correctly check which files are modified and need to
be recompiled. Indeed, if you do `./configure;make` and then you re-run
`make`, many files and operations will be re-done, even if nothing has
changed. `meson` on the other hand keeps track of what is changed and it only
re-builds those files that actually changed and other build targets that
depend on them. This is extremely important for developers, as while
developing a feature or a bug they may need to compile Rizin multiple times.
- `meson` can run everywhere `python3` can. This includes a very wide range
of platforms nowadays. It automatically provides a very powerful scripting
language, python, that you are guaranteed to find on the build machine.
Moreover, it can be used with various backends, like Ninja, Visual Studio and
Xcode, which means it can be used to generate a Visual Studio solution that
you can import there.
- It forces you to build out-of-source, meaning that no changes (mostly) will
be done to your source directory, which must contain only the source files of
your project and not be mixed with other auto-generated files. This also
allows you to have the project compiled with different options or with
slightly different code, cleanly separated in different directories.

# Examples of using meson

## Development process
When I download Rizin, I install it for my user in `~/.local`, so I don't need
root access to install files. I do this with `meson --prefix=~/.local build;
ninja -C build install`. After that, I can change the source code however I
need and then I usually run `ninja` again with `ninja -C build`. Only the
changed files are re-built. Moreover, `ninja` by default builds files with
RPATH, which means that the executables/libraries are directly "linked" with
the dependent libraries that are built. For this reason, most of the times I
don't need to re-install the Rizin files every time, but while developing I
can just run rizin from `./build/binrz/rizin/rizin`.

RPATH are not, of course, always good. Indeed they are usually removed during
the installation process. However, when the user installs Rizin in a place
that is not `/usr`, we have chosen to keep it to make the installation
process as simple as possible, without requiring users to mess with their
environment to make sure the binaries can find the proper libraries.
Packagers, who usually use `/usr` as prefx, should not be affected by this
decision, but they can anyway disable it by specifying `-Dlocal=false` when
running meson.

## Reviewing a PR and testing changes
When testing a PR with a fix or comparing multiple changes, I need to have
access to multiple versions of Rizin. Doing this with ACR/Make is of course
possible, but it usually involves installing everything in separated
directories and making sure your environment variables (e.g. PATH,
LD_LIBRARY_PATH, etc.) are correctly set. With meson I can build one version
(e.g. from `dev` branch) with `meson --prefix=~/.local build-dev; ninja -C
build-dev`, then switch branch with `git checkout my-other-branch` and build
Rizin again with `meson --prefix=~/.local build-pr; ninja -C build-pr`. Due
to the RPATH used by default, as mentioned above, each build directory can be
used without installation to actually run the Rizin tools. At that point I
can quickly compare the results of `./build-dev/binrz/rizin/rizin` and
`./build-pr/binrz/rizin/rizin`.

# Problems with current setup
Of course it's not all perfect with meson either. Right now the meson build
system is missing some features that were only available with ACR/Make. For
example, on MacOS your generated `rizin` binary won't be able to debug other
binaries, because it needs to be signed. Please look at [issue XXX]() for
more info about this. Moreover, to uninstall Rizin you have to run `ninja -C
build uninstall` from the same build directory you used to run the `install`
step, otherwise it will not uninstall files. However if during `install`
step we add any custom installation script (e.g. to sign your rizin binary in
MacOS), there is no counter part to actually have a uninstall script.

These are not impossible issues to overcome, but they just need to be
implemented in our meson files. Moreover, Meson is quite new and, although
rare, you may find issues from time to time. That said, we believe the result
will be cleaner and more portable than relying on sh scripts.

I hope this was a useful overview for developers to understand why we
switched to meson. If you find issues or particular installation setups you
are missing, feel free to open a bug in GitHub and we will be happy to either
guide you through a solution or develop the fix according to our roadmap.